/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { CheckboxValue, } from "./components/checkbox/checkbox";
import { CheckboxGroupValue, } from "./components/checkbox-group/checkbox-group";
import { ChipsValueRemove, ChipsValueSelect, } from "./components/chips/chips";
import { ChipsGroupValue, } from "./components/chips-group/chips-group";
import { RadioValue, } from "./components/radio/radio";
import { RadioGroupValue, } from "./components/radio-group/radio-group";
import { SwitchValue, } from "./components/switch/switch";
import { SwitchGroupValue, } from "./components/switch-group/switch-group";
export namespace Components {
    interface WeAccordion {
        /**
          * Indentify if accordion is opened of not
         */
        "open": boolean;
    }
    interface WeAccordionGroup {
        /**
          * Identify if this accordion group contains more accordions or only once
         */
        "multiple": boolean;
    }
    interface WeButton {
        /**
          * If you use label prop you can create simple button with only text, if you want to use button with many things inside don't use label prop but put the contents inside the tag we-button
         */
        "label": string;
        /**
          * Value returned from buttonCallback event when button will be pressed
         */
        "value": string;
    }
    interface WeCard {
    }
    interface WeCheckbox {
        /**
          * identify if this checkbox is checked or not when the page is loaded
         */
        "checked": boolean;
        /**
          * Identify if this checkbox is disabled or not
         */
        "disabled": boolean;
        /**
          * Value returned when the input is submitted if this checkbox is checked
         */
        "value": string;
    }
    interface WeCheckboxGroup {
        /**
          * Value that identify this checkbox group
         */
        "value": string;
    }
    interface WeChips {
        /**
          * If true user can select the chips and selectChipsCallback event is triggered
         */
        "isSelectable": boolean;
        /**
          * Center text written inside the chips if you want a text inside the chips
         */
        "label": string;
        /**
          * If true the chips will be removed when user click on left image inside chips and removeChipsCallback event is triggered
         */
        "removeLeft": boolean;
        /**
          * If true the chips will be removed when user click on right image inside chips and removeChipsCallback event is triggered
         */
        "removeRight": boolean;
        /**
          * Src of img you want to put in left side of chips if you want an image in that position
         */
        "srcImgLeft": string;
        /**
          * Src of img you want to put in right side of chips if you want an image in that position
         */
        "srcImgRight": string;
        /**
          * Value passed on event when chips selected or removed
         */
        "value": string;
    }
    interface WeChipsGroup {
        /**
          * Value that identify this chips group
         */
        "value": string;
    }
    interface WeDivider {
    }
    interface WeDropdownGroup {
        /**
          * Define the orientation of the objects inside this group, "column" or "row"
         */
        "orientation": string;
    }
    interface WeDropdownItem {
        /**
          * Arrow direction when dropdown is opened/closed inserted in this way: ["arrow_closed","arrow_opened"], values accepted: right, left, up, down
         */
        "arrow": string;
        /**
          * Prop update from dropdown group depend on the orientation the dropdown item is put in order to draw a line separation between them
         */
        "borderClass": string;
        /**
          * Height of the children container when is opened/closed, insert it if you want a transition of height in this way: ["height_close", "height_open"], usually the height_close is 0
         */
        "height": string;
        /**
          * Text inside the dropdown item if you want to use a simple dropdown item with only text
         */
        "label": string;
        /**
          * In which position you want put children relative to the parent dropdown item: right, left, bottom, top <br> Choosen the position you can also modify the css variables that define the position
         */
        "positionChildren": string;
        /**
          * Value put in payload of event triggered when dropdown item is clicked
         */
        "value": string;
        /**
          * Width of the children container when is opened/closed, insert it if you want a transition of width in this way: ["width_close", "width_open"], usually the width_close is 0
         */
        "width": string;
    }
    interface WeList {
    }
    interface WeListItem {
        /**
          * If you want to use a simple tooltip you can only add this value
         */
        "value": string;
    }
    interface WeModal {
        /**
          * identify if modal is visible or not
         */
        "isVisible": boolean;
    }
    interface WeNavigationDrawer {
        /**
          * If true the navigation drawer is closed
         */
        "closed": boolean;
    }
    interface WeRadio {
        /**
          * identify if this radio button is checked or not when the page is loaded
         */
        "checked": boolean;
        /**
          * Identify if this radio button is disabled or not
         */
        "disabled": boolean;
        /**
          * Value returned when the input is submitted if this radio button is checked
         */
        "value": string;
    }
    interface WeRadioGroup {
        /**
          * Value that identify this radio group
         */
        "value": string;
    }
    interface WeSlider {
        /**
          * Event triggered any time user moves the slider putting in the payload name and current value
         */
        "changeCallback": any;
        /**
          * Identify if slider is disabled or not
         */
        "disabled": boolean;
        /**
          * Maximum value you can set in the slider
         */
        "max": number;
        /**
          * Minimum value you can set in the slider
         */
        "min": number;
        /**
          * Name of slider, put in the payload of changeCallback event
         */
        "name": string;
        /**
          * Starting value of slider
         */
        "value": number;
    }
    interface WeSwitch {
        /**
          * Default value of switch when component is rendered the first time
         */
        "checked": boolean;
        /**
          * Text put in the left of switch
         */
        "labelLeft": string;
        /**
          * Text put in the right of switch
         */
        "labelRight": string;
        /**
          * Value of switch, put in the payload of changeCallback event
         */
        "value": string;
    }
    interface WeSwitchGroup {
        /**
          * Name that identify this switch group
         */
        "value": string;
    }
    interface WeTab {
        /**
          * Default value of tab (opened/closed) when component is triggered the first time
         */
        "enabled": boolean;
    }
    interface WeTabGroup {
    }
    interface WeTextarea {
        /**
          * Identify the autofocus property of textarea
         */
        "autofocus": boolean;
        /**
          * Identify the cols property of textarea
         */
        "cols": any;
        /**
          * Identify the disabled property of textarea
         */
        "disabled": boolean;
        /**
          * Identify the maxlength property of textarea
         */
        "maxlength": number;
        /**
          * Name prop of the textarea
         */
        "name": string;
        /**
          * Placeholder appear when there isn't text in the textarea
         */
        "placeholder": string;
        /**
          * Identify the readonly property of textarea
         */
        "readonly": boolean;
        /**
          * Identify the required property of textarea
         */
        "required": boolean;
        /**
          * Identify the rows property of textarea
         */
        "rows": any;
        /**
          * Test inside the textarea when rendered the first time
         */
        "text": string;
    }
    interface WeTooltip {
        /**
          * If you want to use a simple tooltip you can only add this value
         */
        "value": string;
    }
}
declare global {
    interface HTMLWeAccordionElement extends Components.WeAccordion, HTMLStencilElement {
    }
    var HTMLWeAccordionElement: {
        prototype: HTMLWeAccordionElement;
        new (): HTMLWeAccordionElement;
    };
    interface HTMLWeAccordionGroupElement extends Components.WeAccordionGroup, HTMLStencilElement {
    }
    var HTMLWeAccordionGroupElement: {
        prototype: HTMLWeAccordionGroupElement;
        new (): HTMLWeAccordionGroupElement;
    };
    interface HTMLWeButtonElement extends Components.WeButton, HTMLStencilElement {
    }
    var HTMLWeButtonElement: {
        prototype: HTMLWeButtonElement;
        new (): HTMLWeButtonElement;
    };
    interface HTMLWeCardElement extends Components.WeCard, HTMLStencilElement {
    }
    var HTMLWeCardElement: {
        prototype: HTMLWeCardElement;
        new (): HTMLWeCardElement;
    };
    interface HTMLWeCheckboxElement extends Components.WeCheckbox, HTMLStencilElement {
    }
    var HTMLWeCheckboxElement: {
        prototype: HTMLWeCheckboxElement;
        new (): HTMLWeCheckboxElement;
    };
    interface HTMLWeCheckboxGroupElement extends Components.WeCheckboxGroup, HTMLStencilElement {
    }
    var HTMLWeCheckboxGroupElement: {
        prototype: HTMLWeCheckboxGroupElement;
        new (): HTMLWeCheckboxGroupElement;
    };
    interface HTMLWeChipsElement extends Components.WeChips, HTMLStencilElement {
    }
    var HTMLWeChipsElement: {
        prototype: HTMLWeChipsElement;
        new (): HTMLWeChipsElement;
    };
    interface HTMLWeChipsGroupElement extends Components.WeChipsGroup, HTMLStencilElement {
    }
    var HTMLWeChipsGroupElement: {
        prototype: HTMLWeChipsGroupElement;
        new (): HTMLWeChipsGroupElement;
    };
    interface HTMLWeDividerElement extends Components.WeDivider, HTMLStencilElement {
    }
    var HTMLWeDividerElement: {
        prototype: HTMLWeDividerElement;
        new (): HTMLWeDividerElement;
    };
    interface HTMLWeDropdownGroupElement extends Components.WeDropdownGroup, HTMLStencilElement {
    }
    var HTMLWeDropdownGroupElement: {
        prototype: HTMLWeDropdownGroupElement;
        new (): HTMLWeDropdownGroupElement;
    };
    interface HTMLWeDropdownItemElement extends Components.WeDropdownItem, HTMLStencilElement {
    }
    var HTMLWeDropdownItemElement: {
        prototype: HTMLWeDropdownItemElement;
        new (): HTMLWeDropdownItemElement;
    };
    interface HTMLWeListElement extends Components.WeList, HTMLStencilElement {
    }
    var HTMLWeListElement: {
        prototype: HTMLWeListElement;
        new (): HTMLWeListElement;
    };
    interface HTMLWeListItemElement extends Components.WeListItem, HTMLStencilElement {
    }
    var HTMLWeListItemElement: {
        prototype: HTMLWeListItemElement;
        new (): HTMLWeListItemElement;
    };
    interface HTMLWeModalElement extends Components.WeModal, HTMLStencilElement {
    }
    var HTMLWeModalElement: {
        prototype: HTMLWeModalElement;
        new (): HTMLWeModalElement;
    };
    interface HTMLWeNavigationDrawerElement extends Components.WeNavigationDrawer, HTMLStencilElement {
    }
    var HTMLWeNavigationDrawerElement: {
        prototype: HTMLWeNavigationDrawerElement;
        new (): HTMLWeNavigationDrawerElement;
    };
    interface HTMLWeRadioElement extends Components.WeRadio, HTMLStencilElement {
    }
    var HTMLWeRadioElement: {
        prototype: HTMLWeRadioElement;
        new (): HTMLWeRadioElement;
    };
    interface HTMLWeRadioGroupElement extends Components.WeRadioGroup, HTMLStencilElement {
    }
    var HTMLWeRadioGroupElement: {
        prototype: HTMLWeRadioGroupElement;
        new (): HTMLWeRadioGroupElement;
    };
    interface HTMLWeSliderElement extends Components.WeSlider, HTMLStencilElement {
    }
    var HTMLWeSliderElement: {
        prototype: HTMLWeSliderElement;
        new (): HTMLWeSliderElement;
    };
    interface HTMLWeSwitchElement extends Components.WeSwitch, HTMLStencilElement {
    }
    var HTMLWeSwitchElement: {
        prototype: HTMLWeSwitchElement;
        new (): HTMLWeSwitchElement;
    };
    interface HTMLWeSwitchGroupElement extends Components.WeSwitchGroup, HTMLStencilElement {
    }
    var HTMLWeSwitchGroupElement: {
        prototype: HTMLWeSwitchGroupElement;
        new (): HTMLWeSwitchGroupElement;
    };
    interface HTMLWeTabElement extends Components.WeTab, HTMLStencilElement {
    }
    var HTMLWeTabElement: {
        prototype: HTMLWeTabElement;
        new (): HTMLWeTabElement;
    };
    interface HTMLWeTabGroupElement extends Components.WeTabGroup, HTMLStencilElement {
    }
    var HTMLWeTabGroupElement: {
        prototype: HTMLWeTabGroupElement;
        new (): HTMLWeTabGroupElement;
    };
    interface HTMLWeTextareaElement extends Components.WeTextarea, HTMLStencilElement {
    }
    var HTMLWeTextareaElement: {
        prototype: HTMLWeTextareaElement;
        new (): HTMLWeTextareaElement;
    };
    interface HTMLWeTooltipElement extends Components.WeTooltip, HTMLStencilElement {
    }
    var HTMLWeTooltipElement: {
        prototype: HTMLWeTooltipElement;
        new (): HTMLWeTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "we-accordion": HTMLWeAccordionElement;
        "we-accordion-group": HTMLWeAccordionGroupElement;
        "we-button": HTMLWeButtonElement;
        "we-card": HTMLWeCardElement;
        "we-checkbox": HTMLWeCheckboxElement;
        "we-checkbox-group": HTMLWeCheckboxGroupElement;
        "we-chips": HTMLWeChipsElement;
        "we-chips-group": HTMLWeChipsGroupElement;
        "we-divider": HTMLWeDividerElement;
        "we-dropdown-group": HTMLWeDropdownGroupElement;
        "we-dropdown-item": HTMLWeDropdownItemElement;
        "we-list": HTMLWeListElement;
        "we-list-item": HTMLWeListItemElement;
        "we-modal": HTMLWeModalElement;
        "we-navigation-drawer": HTMLWeNavigationDrawerElement;
        "we-radio": HTMLWeRadioElement;
        "we-radio-group": HTMLWeRadioGroupElement;
        "we-slider": HTMLWeSliderElement;
        "we-switch": HTMLWeSwitchElement;
        "we-switch-group": HTMLWeSwitchGroupElement;
        "we-tab": HTMLWeTabElement;
        "we-tab-group": HTMLWeTabGroupElement;
        "we-textarea": HTMLWeTextareaElement;
        "we-tooltip": HTMLWeTooltipElement;
    }
}
declare namespace LocalJSX {
    interface WeAccordion {
        /**
          * Event triggered each time the accordion is opened/closed
         */
        "onAccordionCallback"?: (event: CustomEvent<any>) => void;
        /**
          * Indentify if accordion is opened of not
         */
        "open"?: boolean;
    }
    interface WeAccordionGroup {
        /**
          * Identify if this accordion group contains more accordions or only once
         */
        "multiple"?: boolean;
    }
    interface WeButton {
        /**
          * If you use label prop you can create simple button with only text, if you want to use button with many things inside don't use label prop but put the contents inside the tag we-button
         */
        "label"?: string;
        /**
          * Event triggered when button is pressed
         */
        "onButtonCallback"?: (event: CustomEvent<any>) => void;
        /**
          * Value returned from buttonCallback event when button will be pressed
         */
        "value": string;
    }
    interface WeCard {
    }
    interface WeCheckbox {
        /**
          * identify if this checkbox is checked or not when the page is loaded
         */
        "checked"?: boolean;
        /**
          * Identify if this checkbox is disabled or not
         */
        "disabled"?: boolean;
        /**
          * Event triggered when this checkbox is checked/not checked returning the value prop for payload
         */
        "onCheckboxCallback"?: (event: CustomEvent<CheckboxValue>) => void;
        /**
          * Value returned when the input is submitted if this checkbox is checked
         */
        "value": string;
    }
    interface WeCheckboxGroup {
        /**
          * Event triggered when a checkbox inside change its state that returning the value of checkbox group and the value of checkbox changed
         */
        "onCheckboxGroupCallback"?: (event: CustomEvent<CheckboxGroupValue>) => void;
        /**
          * Value that identify this checkbox group
         */
        "value": string;
    }
    interface WeChips {
        /**
          * If true user can select the chips and selectChipsCallback event is triggered
         */
        "isSelectable"?: boolean;
        /**
          * Center text written inside the chips if you want a text inside the chips
         */
        "label"?: string;
        /**
          * Event triggered when the chips is removed
         */
        "onRemoveChipsCallback"?: (event: CustomEvent<ChipsValueRemove>) => void;
        /**
          * Event triggered when the chips is selected
         */
        "onSelectChipsCallback"?: (event: CustomEvent<ChipsValueSelect>) => void;
        /**
          * If true the chips will be removed when user click on left image inside chips and removeChipsCallback event is triggered
         */
        "removeLeft"?: boolean;
        /**
          * If true the chips will be removed when user click on right image inside chips and removeChipsCallback event is triggered
         */
        "removeRight"?: boolean;
        /**
          * Src of img you want to put in left side of chips if you want an image in that position
         */
        "srcImgLeft"?: string;
        /**
          * Src of img you want to put in right side of chips if you want an image in that position
         */
        "srcImgRight"?: string;
        /**
          * Value passed on event when chips selected or removed
         */
        "value": string;
    }
    interface WeChipsGroup {
        "onChipsGroupCallback"?: (event: CustomEvent<ChipsGroupValue>) => void;
        /**
          * Value that identify this chips group
         */
        "value": string;
    }
    interface WeDivider {
    }
    interface WeDropdownGroup {
        /**
          * Define the orientation of the objects inside this group, "column" or "row"
         */
        "orientation"?: string;
    }
    interface WeDropdownItem {
        /**
          * Arrow direction when dropdown is opened/closed inserted in this way: ["arrow_closed","arrow_opened"], values accepted: right, left, up, down
         */
        "arrow"?: string;
        /**
          * Prop update from dropdown group depend on the orientation the dropdown item is put in order to draw a line separation between them
         */
        "borderClass"?: string;
        /**
          * Height of the children container when is opened/closed, insert it if you want a transition of height in this way: ["height_close", "height_open"], usually the height_close is 0
         */
        "height"?: string;
        /**
          * Text inside the dropdown item if you want to use a simple dropdown item with only text
         */
        "label"?: string;
        /**
          * Event triggered when dropdown item is clicked, not the arrow
         */
        "onClickItemCallback"?: (event: CustomEvent<any>) => void;
        /**
          * In which position you want put children relative to the parent dropdown item: right, left, bottom, top <br> Choosen the position you can also modify the css variables that define the position
         */
        "positionChildren"?: string;
        /**
          * Value put in payload of event triggered when dropdown item is clicked
         */
        "value"?: string;
        /**
          * Width of the children container when is opened/closed, insert it if you want a transition of width in this way: ["width_close", "width_open"], usually the width_close is 0
         */
        "width"?: string;
    }
    interface WeList {
    }
    interface WeListItem {
        /**
          * If you want to use a simple tooltip you can only add this value
         */
        "value"?: string;
    }
    interface WeModal {
        /**
          * identify if modal is visible or not
         */
        "isVisible"?: boolean;
        /**
          * Event triggered when the visibility of modal change
         */
        "onModalCallback"?: (event: CustomEvent<any>) => void;
    }
    interface WeNavigationDrawer {
        /**
          * If true the navigation drawer is closed
         */
        "closed"?: boolean;
    }
    interface WeRadio {
        /**
          * identify if this radio button is checked or not when the page is loaded
         */
        "checked"?: boolean;
        /**
          * Identify if this radio button is disabled or not
         */
        "disabled"?: boolean;
        /**
          * Event triggered when this radio button is checked/not checked returning the value prop for payload
         */
        "onRadioCallback"?: (event: CustomEvent<RadioValue>) => void;
        /**
          * Value returned when the input is submitted if this radio button is checked
         */
        "value": string;
    }
    interface WeRadioGroup {
        /**
          * Event triggered when a radio button inside change its state that returning the name of radio group and the value of radio button checked
         */
        "onRadioGroupCallback"?: (event: CustomEvent<RadioGroupValue>) => void;
        /**
          * Value that identify this radio group
         */
        "value": string;
    }
    interface WeSlider {
        /**
          * Event triggered any time user moves the slider putting in the payload name and current value
         */
        "changeCallback"?: any;
        /**
          * Identify if slider is disabled or not
         */
        "disabled"?: boolean;
        /**
          * Maximum value you can set in the slider
         */
        "max"?: number;
        /**
          * Minimum value you can set in the slider
         */
        "min"?: number;
        /**
          * Name of slider, put in the payload of changeCallback event
         */
        "name": string;
        /**
          * Starting value of slider
         */
        "value"?: number;
    }
    interface WeSwitch {
        /**
          * Default value of switch when component is rendered the first time
         */
        "checked"?: boolean;
        /**
          * Text put in the left of switch
         */
        "labelLeft"?: string;
        /**
          * Text put in the right of switch
         */
        "labelRight"?: string;
        /**
          * Event triggered any time user change the state of the switch putting in the payload value and status
         */
        "onSwitchCallback"?: (event: CustomEvent<SwitchValue>) => void;
        /**
          * Value of switch, put in the payload of changeCallback event
         */
        "value": string;
    }
    interface WeSwitchGroup {
        /**
          * Function called when a switch inside change it's state
         */
        "onSwitchGroupCallback"?: (event: CustomEvent<SwitchGroupValue>) => void;
        /**
          * Name that identify this switch group
         */
        "value": string;
    }
    interface WeTab {
        /**
          * Default value of tab (opened/closed) when component is triggered the first time
         */
        "enabled"?: boolean;
        /**
          * Event triggered when user select a tab putting in the payload the value id generated
         */
        "onTabCallback"?: (event: CustomEvent<any>) => void;
    }
    interface WeTabGroup {
    }
    interface WeTextarea {
        /**
          * Identify the autofocus property of textarea
         */
        "autofocus"?: boolean;
        /**
          * Identify the cols property of textarea
         */
        "cols"?: any;
        /**
          * Identify the disabled property of textarea
         */
        "disabled"?: boolean;
        /**
          * Identify the maxlength property of textarea
         */
        "maxlength"?: number;
        /**
          * Name prop of the textarea
         */
        "name"?: string;
        /**
          * Placeholder appear when there isn't text in the textarea
         */
        "placeholder"?: string;
        /**
          * Identify the readonly property of textarea
         */
        "readonly"?: boolean;
        /**
          * Identify the required property of textarea
         */
        "required"?: boolean;
        /**
          * Identify the rows property of textarea
         */
        "rows"?: any;
        /**
          * Test inside the textarea when rendered the first time
         */
        "text"?: string;
    }
    interface WeTooltip {
        /**
          * If you want to use a simple tooltip you can only add this value
         */
        "value"?: string;
    }
    interface IntrinsicElements {
        "we-accordion": WeAccordion;
        "we-accordion-group": WeAccordionGroup;
        "we-button": WeButton;
        "we-card": WeCard;
        "we-checkbox": WeCheckbox;
        "we-checkbox-group": WeCheckboxGroup;
        "we-chips": WeChips;
        "we-chips-group": WeChipsGroup;
        "we-divider": WeDivider;
        "we-dropdown-group": WeDropdownGroup;
        "we-dropdown-item": WeDropdownItem;
        "we-list": WeList;
        "we-list-item": WeListItem;
        "we-modal": WeModal;
        "we-navigation-drawer": WeNavigationDrawer;
        "we-radio": WeRadio;
        "we-radio-group": WeRadioGroup;
        "we-slider": WeSlider;
        "we-switch": WeSwitch;
        "we-switch-group": WeSwitchGroup;
        "we-tab": WeTab;
        "we-tab-group": WeTabGroup;
        "we-textarea": WeTextarea;
        "we-tooltip": WeTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "we-accordion": LocalJSX.WeAccordion & JSXBase.HTMLAttributes<HTMLWeAccordionElement>;
            "we-accordion-group": LocalJSX.WeAccordionGroup & JSXBase.HTMLAttributes<HTMLWeAccordionGroupElement>;
            "we-button": LocalJSX.WeButton & JSXBase.HTMLAttributes<HTMLWeButtonElement>;
            "we-card": LocalJSX.WeCard & JSXBase.HTMLAttributes<HTMLWeCardElement>;
            "we-checkbox": LocalJSX.WeCheckbox & JSXBase.HTMLAttributes<HTMLWeCheckboxElement>;
            "we-checkbox-group": LocalJSX.WeCheckboxGroup & JSXBase.HTMLAttributes<HTMLWeCheckboxGroupElement>;
            "we-chips": LocalJSX.WeChips & JSXBase.HTMLAttributes<HTMLWeChipsElement>;
            "we-chips-group": LocalJSX.WeChipsGroup & JSXBase.HTMLAttributes<HTMLWeChipsGroupElement>;
            "we-divider": LocalJSX.WeDivider & JSXBase.HTMLAttributes<HTMLWeDividerElement>;
            "we-dropdown-group": LocalJSX.WeDropdownGroup & JSXBase.HTMLAttributes<HTMLWeDropdownGroupElement>;
            "we-dropdown-item": LocalJSX.WeDropdownItem & JSXBase.HTMLAttributes<HTMLWeDropdownItemElement>;
            "we-list": LocalJSX.WeList & JSXBase.HTMLAttributes<HTMLWeListElement>;
            "we-list-item": LocalJSX.WeListItem & JSXBase.HTMLAttributes<HTMLWeListItemElement>;
            "we-modal": LocalJSX.WeModal & JSXBase.HTMLAttributes<HTMLWeModalElement>;
            "we-navigation-drawer": LocalJSX.WeNavigationDrawer & JSXBase.HTMLAttributes<HTMLWeNavigationDrawerElement>;
            "we-radio": LocalJSX.WeRadio & JSXBase.HTMLAttributes<HTMLWeRadioElement>;
            "we-radio-group": LocalJSX.WeRadioGroup & JSXBase.HTMLAttributes<HTMLWeRadioGroupElement>;
            "we-slider": LocalJSX.WeSlider & JSXBase.HTMLAttributes<HTMLWeSliderElement>;
            "we-switch": LocalJSX.WeSwitch & JSXBase.HTMLAttributes<HTMLWeSwitchElement>;
            "we-switch-group": LocalJSX.WeSwitchGroup & JSXBase.HTMLAttributes<HTMLWeSwitchGroupElement>;
            "we-tab": LocalJSX.WeTab & JSXBase.HTMLAttributes<HTMLWeTabElement>;
            "we-tab-group": LocalJSX.WeTabGroup & JSXBase.HTMLAttributes<HTMLWeTabGroupElement>;
            "we-textarea": LocalJSX.WeTextarea & JSXBase.HTMLAttributes<HTMLWeTextareaElement>;
            "we-tooltip": LocalJSX.WeTooltip & JSXBase.HTMLAttributes<HTMLWeTooltipElement>;
        }
    }
}
